(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{319:function(n,e,a){"use strict";a.r(e);var t=a(313),i=a(314),o=a.n(i),r=a(315),s=a.n(r),m=a(316),u=a.n(m);a(317);function v(n,e,a,t,i,o,r){try{var s=n[o](r),m=s.value}catch(n){return void a(n)}s.done?e(m):Promise.resolve(m).then(t,i)}function c(n,e){for(var a=0;a<e.length;a++){var t=e[a];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(n,t.key,t)}}var l=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.app=e,this.PARAMS={rotSpeed:.005},this.init()}var e,a,i,r,m;return e=n,(a=[{key:"init",value:(r=regeneratorRuntime.mark((function n(){return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return this.initThree(),this.initBgScene(),n.next=4,this.loadMesh();case 4:this.setupMaterial(),this.initPlane(),this.initRenderTri(),this.setupMouseListener();case 8:case"end":return n.stop()}}),n,this)})),m=function(){var n=this,e=arguments;return new Promise((function(a,t){var i=r.apply(n,e);function o(n){v(i,a,t,o,s,"next",n)}function s(n){v(i,a,t,o,s,"throw",n)}o(void 0)}))},function(){return m.apply(this,arguments)})},{key:"setupMouseListener",value:function(){var n=this;this.mouse=new t.Vector2,this.width=window.innerWidth,this.height=window.innerHeight,document.addEventListener("mousemove",(function(e){var a=e.clientX,t=e.clientY;n.mouse.x=a/n.width*2-1,n.mouse.y=-t/n.height*2+1}))}},{key:"initPlane",value:function(){var n=new t.PlaneBufferGeometry(12,10,32);this.planeMat=new t.ShaderMaterial({fragmentShader:s()("#define GLSLIFY 1\nvarying vec3 vNormal;\nvarying vec3 vColor;\nvarying vec2 vUv;\n\nuniform float u_time;\nuniform sampler2D u_texture;\nuniform vec2 uMouse;\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n  vec2 st = vUv;  \n  vec3 color = vec3(0.0);\n  vec2 pos = vec2(st * 400.0);\n  vec3 outsideColor = vec3(0.0);\n  vec4 textureColor = texture2D(u_texture, vUv);\n\n  float DF = 0.0;\n\n  // add a random position\n  float a = 0.0;\n  vec2 vel = vec2(u_time * 0.1);\n  DF += snoise(pos + vel) * 0.25 + 0.25;\n\n  // add a random position\n  a = snoise(pos * vec2(cos(u_time*0.15), sin(u_time*0.1)) * 0.1) * 3.1415;\n  vel = vec2(cos(a), sin(a));\n  DF += snoise(pos + vel) * 0.25 + uMouse.x * 0.5;\n\n  color = vec3( smoothstep(.7,.75,fract(DF)) );\n\n  // give the noise a gradient based on mouse\n  // color = mix(color, outsideColor, vUv.x + 0.2);\n\n  vec3 edgeStatic = mix(vec3(0.0), vec3(0.05), rand(vec2(vUv.x * u_time, vUv.x)));\n\n  // apply edgeStatic to background\n  // color = mix(color, edgeStatic, smoothstep(0.83, 0.99, vUv.y) + smoothstep(0.83, 0.99, vUv.x));\n\n  gl_FragColor = vec4(color, 1.0);\n}"),vertexShader:s()("#define GLSLIFY 1\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nfloat transpose(float m) {\n  return m;\n}\n\nmat2 transpose(mat2 m) {\n  return mat2(m[0][0], m[1][0],\n              m[0][1], m[1][1]);\n}\n\nmat3 transpose(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}\n\nmat4 transpose(mat4 m) {\n  return mat4(m[0][0], m[1][0], m[2][0], m[3][0],\n              m[0][1], m[1][1], m[2][1], m[3][1],\n              m[0][2], m[1][2], m[2][2], m[3][2],\n              m[0][3], m[1][3], m[2][3], m[3][3]);\n}\n\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvarying vec3 fragPos;\n\nvoid main() {\n  vNormal = mat3(transpose(inverse(modelMatrix))) * normal;\n  vUv = uv;\n\n  fragPos = vec3(modelMatrix * vec4(position, 1.0));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n}"),uniforms:{u_time:{value:0},u_texture:{value:(new t.TextureLoader).load("./all-color.png",(function(n){console.log(n),n.flipY=!1,n.needsUpdate=!0}))},uMouse:{value:0}}}),this.scenePlane=new t.Mesh(n,this.planeMat),this.bgScene.add(this.scenePlane)}},{key:"initTweakPane",value:function(){this.pane=new u.a,this.pane.addInput(this.PARAMS,"rotSpeed",{min:0,max:.5}).on("change",(function(n){}))}},{key:"initThree",value:function(){this.scene=new t.Scene,this.camera=new t.OrthographicCamera,this.renderer=new t.WebGLRenderer({antialias:!0,alpha:!0}),this.renderer.autoClear=!0,this.clock=new t.Clock}},{key:"loadMesh",value:function(){var n=this;return new Promise((function(e,a){(new o.a).load("./noise.glb",(function(a){n.testMesh=a.scene.children[0],console.log(n.testMesh),n.bgScene.add(n.testMesh),e()}))}))}},{key:"setupMaterial",value:function(){var n=new t.ShaderMaterial({fragmentShader:s()("#define GLSLIFY 1\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec2 map(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec3 map(vec3 value, vec3 inMin, vec3 inMax, vec3 outMin, vec3 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec4 map(vec4 value, vec4 inMin, vec4 inMax, vec4 outMin, vec4 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform float u_time;\nuniform sampler2D u_texture;\nuniform vec2 uMouse;\n\nvarying vec3 fragPos;\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvoid main() {\n  vec2 st = vUv;  \n  vec3 color = vec3(0.0);\n  vec2 pos = vec2(st * 300.0);\n  vec3 outsideColor = vec3(0.0);\n  vec4 textureColor = texture2D(u_texture, vUv);\n\n  float DF = 0.0;\n\n  // add a random position\n  float a = 0.0;\n  vec2 vel = vec2(u_time * 0.1);\n  DF += snoise(pos + vel) * 0.25 + 0.25;\n\n  // add a random position\n  a = snoise(pos * vec2(cos(u_time*0.15), sin(u_time*0.1)) * 0.1) * 3.1415;\n  vel = vec2(cos(a), sin(a));\n  DF += snoise(pos + vel) * 0.25 + 0.25;\n\n  color = vec3( smoothstep(.7,.75,fract(DF)) );\n\n  // color = mix(color, outsideColor, textureColor.r);\n\n  // color = mix(color, outsideColor, 1.0);\n\n  ///////////////////////////\n\n  float lightX = map(uMouse.x, -1.0, 1.0, -2.2, 2.2);\n  float lightY = map(uMouse.y, -1.0, 1.0, -2.0, 2.0);\n  vec3 lightPos = vec3(lightX, lightY, 2.0);\n  vec3 norm = normalize(vNormal);\n  vec3 lightDir = normalize(lightPos - fragPos);\n  float diff = max(dot(norm, lightDir), 0.0);\n\n  color = mix(color, outsideColor, 1.0 - diff);\n\n  // color = vec3(diff);\n  gl_FragColor = vec4(color, 1.0);\n}"),vertexShader:s()("#define GLSLIFY 1\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\nfloat transpose(float m) {\n  return m;\n}\n\nmat2 transpose(mat2 m) {\n  return mat2(m[0][0], m[1][0],\n              m[0][1], m[1][1]);\n}\n\nmat3 transpose(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}\n\nmat4 transpose(mat4 m) {\n  return mat4(m[0][0], m[1][0], m[2][0], m[3][0],\n              m[0][1], m[1][1], m[2][1], m[3][1],\n              m[0][2], m[1][2], m[2][2], m[3][2],\n              m[0][3], m[1][3], m[2][3], m[3][3]);\n}\n\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvarying vec3 fragPos;\n\nvoid main() {\n  vNormal = mat3(transpose(inverse(modelMatrix))) * normal;\n  vUv = uv;\n\n  fragPos = vec3(modelMatrix * vec4(position, 1.0));\n\n  // vec3 modPos = mix(position, (position + (normal * 0.5)), vUv.x);\n\n  // gl_Position = projectionMatrix * modelViewMatrix * vec4(modPos,1.0);\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n}"),uniforms:{u_time:{value:0},u_texture:{value:(new t.TextureLoader).load("./all-color.png",(function(n){console.log(n),n.flipY=!1,n.needsUpdate=!0}))},uMouse:{value:0}}});this.testMesh.material=this.testMeshMaterial=n,this.testMesh.material.needsUpdate=!0,this.testMesh.position.z+=.3}},{key:"returnRenderTriGeometry",value:function(){var n=new t.BufferGeometry,e=new Float32Array([-1,-1,3,-1,-1,3]);return n.addAttribute("position",new t.BufferAttribute(e,2)),n}},{key:"initRenderTri",value:function(){this.resize();var n=this.returnRenderTriGeometry(),e=new t.Vector2;this.renderer.getDrawingBufferSize(e),this.RenderTriTarget=new t.WebGLRenderTarget(e.x,e.y,{format:t.RGBFormat,stencilBuffer:!1,depthBuffer:!0}),this.triMaterial=new t.RawShaderMaterial({fragmentShader:s()("precision highp float;\n#define GLSLIFY 1\nuniform sampler2D uScene;\nuniform vec2 uResolution;\nuniform float uTime;\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / uResolution.xy;\n    vec4 color = texture2D(uScene, uv);\n\n    // wavy line\n    // float x = uv.x;\n    // float m = sin(x * 8.0 + uTime) * 0.3;\n    // uv.y -= m;\n    // float line = smoothstep(0.4, 0.5, uv.y) * smoothstep(0.6, 0.5, uv.y);\n    // color = mix(color, vec4(1.0), line);\n    \n    gl_FragColor = vec4(color);\n}"),vertexShader:s()("precision highp float;\n#define GLSLIFY 1\nattribute vec2 position;\n\nvoid main() {\n    // Look ma! no projection matrix multiplication,\n    // because we pass the values directly in clip space coordinates.\n    gl_Position = vec4(position, 1.0, 1.0);\n}"),uniforms:{uScene:{type:"t",value:this.bgRenderTarget.texture},uResolution:{value:e},uTime:{value:0}}});var a=new t.Mesh(n,this.triMaterial);a.frustumCulled=!1,this.scene.add(a)}},{key:"initBgScene",value:function(){this.bgRenderTarget=new t.WebGLRenderTarget(window.innerWidth,window.innerHeight),this.bgCamera=new t.PerspectiveCamera(50,window.innerWidth/window.innerHeight,.01,100),this.bgCamera.position.z=6,this.bgScene=new t.Scene}},{key:"resize",value:function(){this.renderer&&(this.camera.aspect=window.innerWidth/window.innerHeight,this.camera.updateProjectionMatrix(),this.fovHeight=2*Math.tan(this.camera.fov*Math.PI/180/2)*this.camera.position.z,this.fovWidth=this.fovHeight*this.camera.aspect,this.renderer.setSize(window.innerWidth,window.innerHeight),this.trackball&&this.trackball.handleResize())}},{key:"updateTestMesh",value:function(){this.testMesh.rotation.y+=this.PARAMS.rotSpeed}},{key:"update",value:function(){this.clock.getDelta();var n=5e-4*performance.now();this.triMaterial&&(this.triMaterial.uniforms.uTime.value=n),this.testMeshMaterial&&(this.testMeshMaterial.uniforms.u_time.value=n,this.testMeshMaterial.uniforms.uMouse.value=this.mouse),this.planeMat&&(this.planeMat.uniforms.u_time.value=n,this.planeMat.uniforms.uMouse.value=this.mouse),this.testMesh&&this.updateTestMesh(),this.trackball&&this.trackball.update()}},{key:"draw",value:function(){this.renderer.setRenderTarget(this.bgRenderTarget),this.renderer.render(this.bgScene,this.bgCamera),this.renderer.setRenderTarget(null),this.renderer.render(this.scene,this.camera)}}])&&c(e.prototype,a),i&&c(e,i),n}();function b(n,e){for(var a=0;a<e.length;a++){var t=e[a];t.enumerable=t.enumerable||!1,t.configurable=!0,"value"in t&&(t.writable=!0),Object.defineProperty(n,t.key,t)}}a.d(e,"default",(function(){return d}));var d=function(){function n(){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n)}var e,a,t;return e=n,(a=[{key:"init",value:function(){this.initWebGL(),this.addListeners(),this.animate(),this.resize()}},{key:"initWebGL",value:function(){this.webgl=new l(this),document.querySelector(".container").appendChild(this.webgl.renderer.domElement)}},{key:"addListeners",value:function(){this.handlerAnimate=this.animate.bind(this),window.addEventListener("resize",this.resize.bind(this)),window.addEventListener("keyup",this.keyup.bind(this))}},{key:"animate",value:function(){this.update(),this.draw(),this.raf=requestAnimationFrame(this.handlerAnimate)}},{key:"update",value:function(){this.webgl&&this.webgl.update()}},{key:"draw",value:function(){this.webgl&&this.webgl.draw()}},{key:"resize",value:function(){this.webgl&&this.webgl.resize()}},{key:"keyup",value:function(n){82==n.keyCode&&this.webgl.trackball&&this.webgl.trackball.reset()}}])&&b(e.prototype,a),t&&b(e,t),n}()}}]);